字符流：
打印输出字符流
PrintWriter

-------------------------------
自动资源释放

try(声明要释放的资源){

}catch(){

}
-------------------------------
多线程


进程：内存中正在进行的一个应用程序。
线程：进程中的一个执行流程。
多线程：

状态 
生命周期
1.新建
  新建一个 线程对象 Thread t = new Thread();
2.就绪
  t.start();
  等待 cpu的调用
3.运行；
  cpu调用 了 这个线程
  run()
  
4.阻塞
  正在 运行 的线程 由于 某种 原因 暂停了 执行。
  1)同步
    
  2）wait等待

    
  3）其它
     sleep(1000)
     join();
   
5.死亡
  

-------------------------------------------
Java多线程的 应用程序

启动一个java应用程序 至少会 启动 几个线程？

1）主线程 
2）垃圾回收线程


---------------------------------------------
子线程：
 名字 ：系统分配的 是Thread-num  Thread-0

方法：
  1.sleep(时间毫秒)
    当前线程 处于 sleep() ，处于 阻塞状态，
    等 时间 结束了 ，恢复 就绪状态。
  2.isAlive();
  3.join()等待 其它线程运行
     当 线程 A 调用了线程 B的join方法，
      那么 线程A 等待 线程 B 执行完 在 执行。
--------------------------------------
优先级


  1 - 10

1 最低
10最高的
普通 5

----------------------------------------
方法：

  线程中断 
  当线程 A 处于 sleep或 join 状态时，
  被线程 B 执行代码 A.interrupt()是 ，
  线程 A 结束阻塞 进行 异常处理。

  线程让步：
  yield()
   同等优先级 ，让给 相同优先级的线程
   不同优先级 ，让给 优先级高的线程
--------------------------------------------
线程同步

同步
  

同步锁:
 1)
  //同步代码块
	synchronized (this) {
           代码;
				
	}
 2)同步方法
   this

获得同步锁：
  某个 线程 访问  同步代码块 或 同步方法中的代码时
  需要 获得 同步锁。
  这个 线程 获得 了 此对象的同步锁后，其它线程
  就不能 再 访问 此对象 的 同步代码块 或 同步方法了。
  这些线程 进入 到 线程 锁定池 中等待，处于阻塞状态。


释放同步锁：
  1.同步 代码块 或 同步方法中的代码正常执行完了；
  2.                       存在 未能处理的 Error
    或 Exception时 ，释放锁；
  3.                       有 break，return 结束了
   此代码块 或 方法；
  4.                       调用了wait()也会释放锁。



------------------------------------------------------
继承Thread和 实现Runnable接口区别：
   
1.继承Thread类就不能继承其它类。
  实现接口 也 可以继承其它类。
2.继承Thread会继承此类中的 所有属性和方法；
  实现接口 只有 run();
3.实现接口 更 有利于资源共享。




---------------------------------------------------
锁
ReetrantLock 公平锁

可以显示 加锁 和 释放锁。

--------------------------------------------------
wait  和 sleep的区别：

 1.sleep(参数) 必须指定参数
   wait(可选) 参数 可选择
   
 2、sleep(时间)
    放弃了 CPU的执行权，没有放弃锁。
    wait(时间)
    放弃了 cPU的执行权，也 放弃了 锁。















































